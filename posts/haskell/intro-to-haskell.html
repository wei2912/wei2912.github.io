<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <title>Introduction to Haskell</title>

    <link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png" />

    <link rel="stylesheet" href="../../css/main.min.css" />

    

    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <header>November 27, 2014 / <a href="../../" rel="author">Ng Wei En</a> / #haskell</header>
<h1>Introduction to Haskell</h1>

<div id="content"><p>Haskell is one of the most commonly used purely functional programming languages that has been slowly rising in popularity, but haven’t quite caught on to mainstream programmers. (EDIT IN 2019: In recent years, loads of exciting software have been developed in Haskell, like <a href="https://github.com/jgm/pandoc">Pandoc</a>, a marvellous universal markup converter which this blog uses heavily, and <a href="https://github.com/github/semantic">semantic by GitHub</a>, a library for parsing, analyzing and comparing source code.)</p>
<p>You’ll need the <a href="https://www.haskell.org/ghc/">Glasgow Haskell Compiler</a> installed (you can get it as part of <a href="https://www.haskell.org/platform/">Haskell Platform</a>). Then, you’ll be able to evaluate stuff and see what you get.</p>
<h2 id="basics">Basics</h2>
<p>First off, a few basics you need to know about Haskell.</p>
<h3 id="interactive-haskell">Interactive Haskell</h3>
<p>We can use Haskell as a calculator. Let’s start up <code>ghci</code> first:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghci</span></code></pre></div>
<p>We can now type stuff into the prompt…</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">7</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="dv">20</span> <span class="op">-</span> <span class="dv">10</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="dv">9</span> <span class="op">/</span> <span class="dv">0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Infinity</span></span></code></pre></div>
<p>…or check out the types of expressions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span><span class="kw">type</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">5</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Bool</span></span></code></pre></div>
<p>What goes after the double colon is our type. As you can see here, <code>2 + 2 == 5</code> yields a boolean. We’ll see the double colon notation being used later on.</p>
<h3 id="comments">Comments</h3>
<p>Comments can start with <code>--</code>, which lasts till the end of a line, or enclosed within <code>{-</code> and <code>-}</code>. The latter can span multiple lines.</p>
<h3 id="functions">Functions</h3>
<p>Functions are the building block of Haskell. Everything we do in Haskell relies on stringing together functions.</p>
<p>Every function comprises 2 parts:</p>
<ol type="1">
<li>Type signature</li>
<li>Equations</li>
</ol>
<h3 id="type-signature">Type Signature</h3>
<p>The type signature tells us what type the function has. Let’s look at an example:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addByThree ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span></code></pre></div>
<p>The first line is a type signature. In this case, we take in a single Integer and return an Integer.</p>
<p>Now, for a function to add two integers:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span></code></pre></div>
<p>This time round, we take in 2 integers and return a single integer. In Haskell, we usually rely on function naming and type signatures to describe what our function does, rather than pointing out and explaining a whole bunch of statements in our code.</p>
<h3 id="equations">Equations</h3>
<p>Let’s take a look at what the whole of <code>addByThree</code> looks like.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addByThree ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>addByThree x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">3</span></span></code></pre></div>
<p>In Haskell, we write functions similar to equations. The left hand side is <code>addByThree x</code>, which is our function name and the integer <code>x</code>. The right hand side is <code>x + 3</code> which adds 3 to our integer <code>x</code>. Hence, by calling <code>addByThree 10</code> we’ll get back <code>13</code>.</p>
<p>Likewise, our <code>add</code> function is the following:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>You can give these functions a try by pasting this into <code>main.hs</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addByThree ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>addByThree x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">3</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>and then running GHCi:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghci</span></code></pre></div>
<p>Then, typing into the prompt:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span>load main<span class="op">.</span>hs</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">Main</span>             ( main<span class="op">.</span>hs, interpreted )</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Ok</span>, modules loaded<span class="op">:</span> <span class="dt">Main</span><span class="op">.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> addByThree <span class="dv">10</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="dv">13</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> add <span class="dv">10</span> <span class="dv">20</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="dv">30</span></span></code></pre></div>
<h3 id="infix-functions">Infix functions</h3>
<p>Operators like <code>+</code> and <code>*</code> are <em>infix functions</em>, placed between two arguments. We can use them as “normal” functions by enclosing the operator of our choice in brackets. For example, we can rewrite <code>3 + 7</code> as <code>(+) 3 7</code>.</p>
<h3 id="lists">Lists</h3>
<p>Lists in Haskell are <a href="https://en.wikipedia.org/wiki/Linked_list">linked lists</a>. We define lists this way:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="op">:</span><span class="kw">type</span> <span class="st">&quot;abc&quot;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;abc&quot;</span><span class="ot"> ::</span> [<span class="dt">Char</span>]</span></code></pre></div>
<p>Lists in Haskell are implemented as a series of “cons” operations, which join up elements of the list. We use the <code>:</code> operator to do this (otherwise known as the <em>cons</em> operator). It prepends an element to a list of the <em>same type</em>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="dv">3</span> <span class="op">:</span> [<span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>]</span></code></pre></div>
<p>This <code>:</code> operator is <em>right-associative</em>, which means that everything on the right is given precedence and evaluated first.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="dv">3</span> <span class="op">:</span> (<span class="dv">2</span> <span class="op">:</span> (<span class="dv">1</span> <span class="op">:</span> []))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="op">&gt;</span> <span class="dv">3</span> <span class="op">:</span> <span class="dv">2</span> <span class="op">:</span> <span class="dv">1</span> <span class="op">:</span> []</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]</span></code></pre></div>
<h3 id="polymorphic-types">Polymorphic types</h3>
<p><em>Polymorphic types</em> allow for generic types to be used in a function. Take the function<code>id</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>The function <code>id</code> can take in any type, but the use of <code>a</code> as both input and output suggests that the two types have to be the same (note that polymorphic types are lowercase while “normal” types are uppercase).</p>
<p>In our equations, we specified that <code>id x = x</code>. This function just returns the value it was passed into, and so is called the <em>id</em>entity function.</p>
<h3 id="higher-order-functions">Higher Order functions</h3>
<p><em>Higher order functions</em> are functions that can take in or return other functions.</p>
<p>A function which takes in one parameter and returns something of the same type is denoted by <code>a -&gt; a</code>. Similarly, a function that takes in a function and returns something of the same type is <code>(a -&gt; a) -&gt; a</code>.</p>
<p>A very commonly used function is <code>map</code> which applies a function to every value in a list. Let’s look at the type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span></code></pre></div>
<p><code>map</code> takes in a function that changes the type of an element from <code>a</code> to <code>b</code>. It then takes in a list of type <code>a</code> and returns a list of type <code>b</code>.</p>
<p>That’s it for the basics. Let’s get down to some interesting code.</p>
<h2 id="powers-of-a-number">Powers of a number</h2>
<p>Haskell lets us do quite a lot of elegant stuff. Here’s one example that I find to be quite neat:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pows ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>pows base <span class="ot">=</span> <span class="fu">iterate</span> (<span class="op">*</span> base) <span class="dv">1</span></span></code></pre></div>
<p>In here, we define a function that takes in an <em>integer</em> and returns a <em>list of integers</em>. Our equation then defines <code>pows base</code> as <code>iterate (* base) 1</code>.</p>
<h3 id="base"><code>(* base)</code>?</h3>
<p><code>* base</code> looks weird, but it is written with the intention of using <a href="https://en.wikipedia.org/wiki/Partial_application"><em>partially applied functions</em></a>.</p>
<p>Let’s first look at the difference between multiplying 2 integers and multiplying an integer by 3:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">multiply ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>multiply x y <span class="ot">=</span> x <span class="op">*</span> y</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="ot">multiplyByThree ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>multiplyByThree x <span class="ot">=</span> x <span class="op">*</span> <span class="dv">3</span></span></code></pre></div>
<p>We notice that the two functions appear similar. Both take in <code>x</code> and multiply it by a value.</p>
<p>Now, what if we had a way to specify not all arguments to <code>(*)</code> such that we’d get another function? Well, the above functions can be rewritten as:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">multiply ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>multiply x y <span class="ot">=</span> (x <span class="op">*</span>) y</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ot">multiplyByThree ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>multiplyByThree x <span class="ot">=</span> (x <span class="op">*</span>) <span class="dv">3</span></span></code></pre></div>
<p>We provide the left value, <code>x</code>, to <code>(*)</code>. <code>(x *)</code> gives us a function that takes in a single number and multiples that by <code>x</code>. Finally, we get a value. Haskell allows us to supply only a few parameters required, so as to get back a function that takes in the rest of the parameters. This is known as <em>partial application</em>.</p>
<p>How does that help us? This is where <em>higher order functions</em> come in.</p>
<h3 id="the-iterate-function">The <code>iterate</code> function</h3>
<p>Here’s the definition of <code>iterate</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">iterate</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">iterate</span> f x <span class="ot">=</span> x <span class="op">:</span> <span class="fu">iterate</span> f (f x)</span></code></pre></div>
<p>What <code>iterate</code> does is that it prepends a value to a list, applies a function to the value and pass the new value into <code>iterate</code> again. This is what we call a <em>recursive function</em> — a function that calls itself.</p>
<h3 id="trace-of-the-pows-function">Trace of the <code>pows</code> function</h3>
<p>It’s hard to see what this function does if you’re not familiar with recursion, so let’s look at a trace.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>  pows <span class="dv">3</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="fu">iterate</span> (<span class="dv">3</span> <span class="op">*</span>) <span class="dv">1</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> <span class="fu">iterate</span> (<span class="dv">3</span> <span class="op">*</span>) <span class="dv">3</span>           <span class="co">-- 3 * 1</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">3</span> <span class="op">:</span> <span class="fu">iterate</span> (<span class="dv">3</span> <span class="op">*</span>) <span class="dv">9</span>       <span class="co">-- 3 * 3</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">3</span> <span class="op">:</span> <span class="dv">9</span> <span class="op">:</span> <span class="fu">iterate</span> (<span class="dv">3</span> <span class="op">*</span>) <span class="dv">27</span>  <span class="co">-- 3 * 9</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>We can see that we’ll get a list of powers of 3. How this comes about is that we go through the following steps:</p>
<ol type="1">
<li>Prepend the current value to the list</li>
<li>Apply <code>(3 *)</code> to the current value to get a new value.</li>
<li>Apply <code>iterate (3 *)</code> to the new value.</li>
</ol>
<p>Partially applied functions allow us to write this very elegantly, without having to define a new function <code>multiplyByThree</code>. This is one of the lovely things about functional programming — we get to reuse all sorts of functions.</p>
<p>Running that will give us a list of the powers of 3.</p>
<p>But wait! Wouldn’t that go on for infinity? In Haskell, executing <code>pows 3</code> would have given us an infinite list of the powers of 3 (try it and see what happens!). Notice that the list will keep on growing, which looks horrible.</p>
<p>But we can still do stuff with an infinite list, thanks to <em>laziness</em>. We need not evaluate the whole list, but just the items that we need.</p>
<p>From our infinite list,</p>
<pre><code>[1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, ...],</code></pre>
<p>we can do stuff like get the first 5 powers of 3,</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> <span class="dv">5</span> (pows <span class="dv">3</span>)</span></code></pre></div>
<p>which yields</p>
<pre><code>[1, 3, 9, 27, 81]</code></pre>
<p>or maybe get all powers of 2 below 100</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">takeWhile</span> (<span class="op">&lt;</span> <span class="dv">100</span>) (pows <span class="dv">2</span>)</span></code></pre></div>
<p>which yields</p>
<pre><code>[1, 2, 4, 8, 16, 32, 64]</code></pre>
<p>The elegance of this solution lies in the fact that we easily did this with recursion, in a rather terse, clear and “mathematical” way. The ability to reuse functions like this grants us a lot of flexibility in Haskell and allows us to reason about code in a very powerful way.</p>
<h2 id="fibonacci-numbers">Fibonacci Numbers</h2>
<p>Fibonacci numbers start with 0 and 1. Each number is the <em>sum of the previous two numbers</em>. In this example, we’ll handle only natural numbers.</p>
<p>Here’s how the sequence looks like:</p>
<pre><code>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 ...</code></pre>
<p>As you can see, the third number, 1, is the sum of 0 and 1. The fourth number, 2 is the sum of 1 and 1. This sequence goes on forever.</p>
<p>On to the code:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fibs ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>fibs <span class="ot">=</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">1</span> <span class="op">:</span> <span class="fu">zipWith</span> (<span class="op">+</span>) fibs (<span class="fu">tail</span> fibs)</span></code></pre></div>
<p>This time round, we define <code>fibs</code> as a <em>list of integers</em>. We then prepend <code>0</code> and <code>1</code> to <code>zipWith (+) fibs (tail fibs)</code>.</p>
<p>What does <code>zipWith</code> do? Before we cover it, we need to take a look at some list terminology and pattern matching.</p>
<h3 id="lists-1">Lists</h3>
<p>Take a look at this graphical representation:</p>
<pre><code>    +--+--+--+--+--+--+--+--+
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 ^</code></pre>
<p>The top line denotes the elements that make up the <code>tail</code> while the bottom carat denotes the <code>head</code>. To put it in words, the <code>head</code> is the first element of the list, while the <code>tail</code> is everything after the <code>head</code>.</p>
<p>Here’s another graphical representation:</p>
<pre><code> +--+--+--+--+--+--+--+--+
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
                            ^</code></pre>
<p>This time round, the top line denotes the <code>init</code> and the carat denotes the <code>last</code>.</p>
<p><code>tail</code>, <code>head</code>, <code>init</code> and <code>last</code> are all functions. You can try them out in GHCi:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">head</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">tail</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">init</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">last</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<h3 id="zipwith"><code>zipWith</code></h3>
<p>Now that we’ve conquered list terminology, let’s look at <code>zipWith</code>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span> f (a <span class="op">:</span> as) (b <span class="op">:</span> bs) <span class="ot">=</span> f a b <span class="op">:</span> <span class="fu">zipWith</span> f as bs</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span> _ _ _ <span class="ot">=</span> []</span></code></pre></div>
<p>We have 2 equations, with some weird underscores. How does this work?</p>
<p>Haskell allows for pattern matching. In our case, <code>(a : as)</code> seperates a list of values into <code>a</code> (the head) and <code>as</code> (the tail). We do the same with <code>(b : bs)</code>. Afterwards, we apply <code>f</code> to <code>a</code> and <code>b</code>, then prepend our value to <code>zipWith f as bs</code>.</p>
<p>However, there’s still a second equation. Underscores are a way for us to dispose unneeded values. The last clause catches everything that doesn’t fit the first equation and returns an empty list.</p>
<p>But why do we need a catchall? As it turns out, the head of an empty list is undefined. Hence, <code>(a : as)</code> will only match lists with at least one element. Our catchall ensures that the function doesn’t error out when we exhaust both lists. Instead, it returns an empty list.</p>
<p>This is what we call the <code>base case</code> of a recursive function, as all other calls to the recursive function gets reduced to this. It’s also the reason why <code>zipWith</code> terminates while <code>iterate</code> doesn’t.</p>
<p>While we now know what the function is doing, we still have no idea how it works. Looking at the trace should gain some inspiration as to how this works:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span> (<span class="op">+</span>) [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]   <span class="co">-- 1 + 4</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">5</span> <span class="op">:</span> <span class="fu">zipWith</span> (<span class="op">+</span>) [<span class="dv">2</span>, <span class="dv">3</span>] [<span class="dv">5</span>, <span class="dv">6</span>]   <span class="co">-- 2 + 5</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">5</span> <span class="op">:</span> <span class="dv">7</span> <span class="op">:</span> <span class="fu">zipWith</span> (<span class="op">+</span>) [<span class="dv">3</span>] [<span class="dv">6</span>]     <span class="co">-- 3 + 6</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">5</span> <span class="op">:</span> <span class="dv">7</span> <span class="op">:</span> <span class="dv">9</span> <span class="op">:</span> zipwith (<span class="op">+</span>) [] []   <span class="co">-- returns []</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">5</span> <span class="op">:</span> <span class="dv">7</span> <span class="op">:</span> <span class="dv">9</span> <span class="op">:</span> []</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> [<span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span>]</span></code></pre></div>
<p>The comment shows how the <code>(+)</code> function is being applied to the values of the list and how the values turn into a list.</p>
<h3 id="back-to-the-fibs-function.">Back to the <code>fibs</code> function.</h3>
<p><code>zipWith (+) fibs (tail fibs)</code> is still a mystery to us. What could it possibly mean? Let’s look at <code>fibs</code> and <code>tail fibs</code> first (with the values that we already know):</p>
<pre><code>  0 1 ...
+ 1 ...
---------
  1</code></pre>
<p>The first line is <code>fibs</code> and the second line is <code>tail fibs</code>. Adding up the numbers on the first column, 0 and 1, gives us 1, our third number. We append this to the list.</p>
<p>When we evaluate the fourth number, here’s what our list looks like:</p>
<pre><code>  0 1 1 ...
+ 1 1 ...
---------
  1 2</code></pre>
<p>We get the fourth number, 2, and it’s appended to the list. Now, for the fifth number:</p>
<pre><code>  0 1 1 2 ...
+ 1 1 2 ...
---------
  1 2 3</code></pre>
<p>We get 3. This continues, eventually building up a list of Fibonacci numbers.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this has showed you how elegant Haskell could be and why many programmers enjoy working in it. There’s a lot more to Haskell than this (such as functors, monads, etc.) which can make working on code rather nice for the mathematically-inclined.</p>
<p>You can take a look at the following readings:</p>
<ul>
<li><a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf">Why Functional Programming matters</a></li>
</ul>
<p>You may also wish to follow <a href="https://github.com/bitemyapp/learnhaskell">Chris Allen’s guide</a> to learn more about Haskell. (EDIT IN 2019: Chris Allen has finished all the content in <a href="http://haskellbook.com/">his book on Haskell</a> and is <a href="https://gumroad.com/l/haskellbook">offering early access on Gumroad before the book is published</a>.)</p></div>

<hr />

<aside>
  <small>
    <p>
      <em>
        You can view the history of changes made to this post at
        <a href="https://github.com/wei2912/wei2912.github.io/blame/master/posts/haskell/intro-to-haskell.md">this website's GitHub repository</a>.
      </em>
    </p>
  </small>
</aside>

<script src="https://utteranc.es/client.js" repo="wei2912/wei2912.github.io" issue-term="title" label="comments" theme="github-light" crossorigin="anonymous" async></script>

<hr />

    <footer>
      <small>
        <p>
          <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
            <img alt="Creative Commons License" style="border-width: 0" src="https://licensebuttons.net/l/by/4.0/88x31.png" /> </a><br />
          This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.<br />
          The source of the website is available at
          <a href="https://github.com/wei2912/wei2912.github.io">wei2912/wei2912.github.io</a>.<br />
        </p>
      </small>
    </footer>
  </body>
</html>
