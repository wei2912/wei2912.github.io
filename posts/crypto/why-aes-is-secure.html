<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <title>Why AES Is Secure</title>

    <link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png" />

<link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Mono&family=Fira+Sans:wght@300&family=Merriweather&display=swap" rel="stylesheet">

<style> @import url('https://fonts.googleapis.com/css2?family=Fira+Mono&family=Fira+Sans:wght@300&family=Merriweather&display=swap'); </style>
    <link rel="stylesheet" href="../../css/main.min.css" />

    
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous" />
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <!-- End KaTeX Code -->
    

    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <header>January  1, 2017 / <a href="../../" rel="author">Ng Wei En</a> / #crypto</header>
<h1>Why AES Is Secure</h1>

<div id="content"><p>The <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" title="Advanced Encryption Standard">Advanced Encryption Standard</a>, otherwise known as Rijndael (which was its original name), is one of the most widely used ciphers for the encryption of data. It’s been approved by the US government to protect classified data. In this article, I’ll explain how AES works and why it’s secure.</p>
<h2 id="galois-field-theory">Galois field theory</h2>
<p>AES makes extensive use of Galois field theory, which I’m going to give a very brief introduction to. For more details see <a href="http://www.math.washington.edu/~morrow/336_12/papers/juan.pdf" title="Galois Field in Cryptography">Galois Field in Cryptography</a>.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Finite_field" title="Finite field">Galois field</a> is a <a href="https://en.wikipedia.org/wiki/Field_%28mathematics%29" title="Field (mathematics)">field</a> containing a finite number of elements. A field is a set on which the operations of addition, multiplication, subtraction and division meet certain rules. We’ll refer to these rules as they come in useful – don’t worry too much about them.</p>
<p>There’s the field of real numbers and the field of rational numbers. What makes a Galois field different from these fields, is that it contains a finite number of elements (which is why it’s also called a finite field). On the other hand, there is an infinite number of real numbers and rational numbers.</p>
<p>A Galois field is denoted as <span class="math inline">\(GF(p^n)\)</span> where <span class="math inline">\(p\)</span> is a prime number and <span class="math inline">\(n\)</span> is a positive integer. We call <span class="math inline">\(p^n\)</span> the order of the field. The elements of a Galois field are the set of elements <span class="math inline">\(\{0, 1, 2, \ldots, p^n - 1\}\)</span>.</p>
<h3 id="galois-field-arithmetic">Galois field arithmetic</h3>
<p>Firstly, let’s take a look at <span class="math inline">\(GF(p)\)</span>. Addition and multiplication is done similarly to integers, followed by modulo <span class="math inline">\(p\)</span> (this is just finding the remainder after dividing by <span class="math inline">\(p\)</span>). For example, in <span class="math inline">\(GF(5)\)</span>, <span class="math inline">\(4 + 3 = 7\)</span> is reduced to <span class="math inline">\(2\)</span>, and <span class="math inline">\(4 \times 2 = 8\)</span> is reduced to <span class="math inline">\(3\)</span>.</p>
<p>Elements of <span class="math inline">\(GF(p^n)\)</span> can be represented as polynomials of degree less than <span class="math inline">\(n\)</span>. For example, in <span class="math inline">\(GF(3^3)\)</span>, the polynomial <span class="math inline">\(x^2 + 1\)</span> would represent 10 and the polynomial <span class="math inline">\(2x^2 + x + 1\)</span> would represent 22, with <span class="math inline">\(x = 3\)</span>. In addition, we use modulo <span class="math inline">\(3\)</span> on each of the coefficients. Adding up the two polynomials gives us <span class="math inline">\(3x^2 + x + 2\)</span>, which is reduced to <span class="math inline">\(x + 2\)</span>, represented as 5.</p>
<p>However, things get more complicated when it comes to multiplication. Take the polynomials <span class="math inline">\(2x^2 + 1\)</span> and <span class="math inline">\(x + 1\)</span>. Multiplying these two would give us <span class="math inline">\((2x^2 + 1)(x + 1) = 2x^3 + 2x^2 + x + 1\)</span>. At this point, we’ve exceeded the order of the field! The way to resolve this is to modulo a suitable polynomial, by long division. There are certain rules for selecting this polynomial, which I will not discuss.</p>
<h3 id="use-of-galois-field-theory-in-aes">Use of Galois field theory in AES</h3>
<p>In AES, where we want to manipulate bytes, <span class="math inline">\(GF(2^8)\)</span> is used. <span class="math inline">\(GF(2^8)\)</span> has a set of elements which represent all possible values of a byte. The fact that the addition and multiplication operations are closed (that is, applying addition and multiplication to any two elements will always return an element that is in the set of elements of that field) makes the Galois field very convenient for manipulating bytes, as operations can be done on any two bytes to get a new byte.</p>
<p>It also turns out that addition of two elements in <span class="math inline">\(GF(2^8)\)</span> is simply XOR of both elements – this means that addition is efficient on hardware! On the other hand, multiplication is more complex. AES uses the polynomial <span class="math inline">\(x^8 + x^4 + x^3 + x + 1\)</span>, and most implementations will use a lookup table instead of computing the polynomial for the sake of efficiency.</p>
<h2 id="overview-of-aes">Overview of AES</h2>
<p>Now that we’re done with basic Galois field theory, it’s time to take a look at how AES is implemented.</p>
<p>AES can be represented by two functions, <span class="math inline">\(E(k, p)\)</span> and <span class="math inline">\(D(k, c)\)</span> where <span class="math inline">\(k\)</span> is the key, <span class="math inline">\(p\)</span> is the plaintext and <span class="math inline">\(c\)</span> is the ciphertext. The former represents encryption, and the latter represents decryption. A valid encryption scheme would ensure that <span class="math inline">\(D(k, E(k, p)) = p\)</span> for any <span class="math inline">\(k\)</span> and <span class="math inline">\(p\)</span>.</p>
<p>AES has 3 key sizes: 128, 192 and 256 bits. It is known as a block cipher; that means it encrypts plaintext in seperate blocks of fixed size, as opposed to a stream cipher which encrypts plaintext bit by bit. Its block size is 128 bits.</p>
<figure>
<img src="../../public/crypto/why-aes-is-secure/aes-arch.png" alt="AES Architecture (Credits: Vishwanath et al. (2016))" />
<figcaption aria-hidden="true">AES Architecture (Credits: <a href="https://www.mecs-press.org/ijitcs/ijitcs-v8-n5/v8n5-3.html">Vishwanath et al. (2016)</a>)</figcaption>
</figure>
<p>AES takes in 16 bytes, <span class="math inline">\(b_0, b_1, \dots, b_{15}\)</span>, which are arranged in a matrix from top to bottom, left to right:</p>
<p><span class="math display">\[
\begin{bmatrix}
b_0 &amp; b_4 &amp; b_8    &amp; b_{12} \\
b_1 &amp; b_5 &amp; b_9    &amp; b_{13} \\
b_2 &amp; b_6 &amp; b_{10} &amp; b_{14} \\
b_3 &amp; b_7 &amp; b_{11} &amp; b_{15} \\
\end{bmatrix}
\]</span></p>
<p>AES can be broken down into 4 steps:</p>
<ol type="1">
<li><code>SubBytes</code></li>
<li><code>ShiftRows</code></li>
<li><code>MixColumns</code></li>
<li><code>AddRoundKey</code></li>
</ol>
<p>These 4 steps make up a round. Before the first round, <code>AddRoundKey</code> is performed, and in the last round, <code>MixColumns</code> is omitted.</p>
<p>The number of rounds for AES is based on the key size:</p>
<ol type="1">
<li>AES-128: 128 bit key, 10 rounds</li>
<li>AES-192: 192 bit key, 12 rounds</li>
<li>AES-256: 256 bit key, 14 rounds</li>
</ol>
<h3 id="substitution-permutation-network">Substitution Permutation Network</h3>
<p>AES has a structure known as a <a href="https://en.wikipedia.org/wiki/Substitution-permutation_network" title="Substitution-permutation network">substitution-permutation network (SPN)</a>, which takes in plaintext and keys as inputs.</p>
<figure>
<img src="../../public/crypto/why-aes-is-secure/spn-img.png" alt="Substitution-Permutation Network (Credits: Wikimedia)" />
<figcaption aria-hidden="true">Substitution-Permutation Network (Credits: <a href="https://commons.wikimedia.org/wiki/File:SubstitutionPermutationNetwork2.png">Wikimedia</a>)</figcaption>
</figure>
<p>Each round looks like this:</p>
<ol type="1">
<li>Combination of the plaintext with the round key (represented by <span class="math inline">\(\oplus\)</span>)</li>
<li>Substitution of small blocks of bits (referred to as a S-box, or a <strong>s</strong>ubstitution box)</li>
<li>Permutation of all the bits (referred to as a P-box, or a <strong>p</strong>ermutation box)</li>
</ol>
<p>The combination of the plaintext with the round key is often XOR, as XOR is easily invertible (<span class="math inline">\(A \oplus (A \oplus B) = B\)</span>, as <span class="math inline">\(A \oplus A = 0\)</span> and XORing anything against 0 does not change the result.) Decryption, hence, is merely XORing against the corresponding round key. At the same time, the S-box and P-box should also be invertible. This means that decryption for a SPN is merely the reverse process.</p>
<p>A good S-box should offer various properties. Firstly, for it to be invertible, the substitution should be one-to-one. This means that the length of the output should be the same as the length of the input. This allows for decryption. Secondly, changing a single input bit should change about half of the output bits. This is known as the <a href="https://en.wikipedia.org/wiki/Avalanche_effect" title="Avalanche effect">avalanche effect</a>.</p>
<p>A good P-box should ensure that the output bits of any S-box is distributed across the permutation. The reason for doing this is covered in the next section.</p>
<p>By itself, the S-box is a <a href="https://en.wikipedia.org/wiki/Substitution_cipher" title="Substitution cipher">substitution cipher</a>, and the P-box is a <a href="https://en.wikipedia.org/wiki/Transposition_cipher" title="Transposition cipher">transposition cipher</a>. Both ciphers hardly offer any cryptographic strength, as they reveal statistical properties. However, when combined together, they provide powerful cryptographic strength.</p>
<h3 id="confusion-and-diffusion">Confusion and Diffusion</h3>
<p><a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion" title="Confusion and diffusion">Confusion and diffusion</a> are key properties of a secure cipher (as identified by Claude Shannon, considered the father of information theory). <em>Confusion</em> refers to the property that each character of the ciphertext depends on several parts of the key, and <em>diffusion</em> refers to the property that when we change a character of the plaintext, then several characters of the ciphertext should change.</p>
<p>Firstly, if a single bit is changed in the plaintext, an S-Box changes several bits. The P-Box then distributes these changed bits across. With several rounds, the ciphertext has changed completely. This satisfies the property of <em>diffusion</em>. Other than having a completely different ciphertext, this also prevents an attacker from modifying the ciphertext in order to get a desired plaintext, as this would change the plaintext drastically.</p>
<p>Secondly, the SPN also exhibits <em>confusion</em> (under the assumption that changing one bit of the key changes several round keys – the SPN does not include derivation of the round keys). Every change in a round key causes a change in the input of the S-Boxes. As per the property of diffusion, the ciphertext would be drastically altered. This means that each of the output bits would depend on several parts of the round keys, which in turn depend on the key. This satisfies the property of confusion.</p>
<p>The power of the SPN lies in how it allows for both properties to be exhibited, despite being so simple and efficient.</p>
<h3 id="key-schedule">Key Schedule</h3>
<p>Each round has a certain key of its own, derived from the key given. The algorithm to obtain the round keys is called the <a href="https://en.wikipedia.org/wiki/Key_schedule" title="Key schedule">key schedule</a>.</p>
<p>With a larger key size, AES has a larger number of rounds. The reason is that given more key bits, there is a need for more rounds so as to ensure that there is <em>confusion</em>. This is why the key schedule differs depending on the key size.</p>
<p>The key schedule derives the first round key from the master key, the second from the first, and so on until all round keys required have been generated. I will not elaborate much on how the key schedule works. The main point to note is that the key schedule consists of shifting bytes and XOR operations. The key schedule is invertible, allowing an adversary to derive the master key given any round key.</p>
<p>A question you may ask is, why not use a <a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" title="Cryptographically secure pseudorandom number generator">cryptographically secure pseudorandom number generator</a>? One could seed the generator with the key, providing a sequence of output round keys that are hard to predict and increasing the difficulty of obtaining the master key from the key schedule.</p>
<p>Simply put, a simpler key schedule provides efficiency but comes at the cost of a bit of security. However, practically speaking, there is not much need to make the key schedule non-invertible.</p>
<p>Despite the weakness of the key schedule, it satisfies the property that changing one bit of the key changes several round keys, which was a requirement for a SPN to be secure.</p>
<p>For more details, you can read <a href="http://crypto.stackexchange.com/a/5120" title="Is AES-256 weaker than 192 and 128 bit versions?">Thomas Pornin’s answer on Crypto StackExchange</a> on why a simpler key schedule is used, and <a href="http://crypto.stackexchange.com/a/1709" title="Is the AES Key Schedule weak?">poncho’s answer</a> on why making the key schedule non-invertible will not add much security.</p>
<h3 id="subbytes"><code>SubBytes</code></h3>
<figure>
<img src="../../public/crypto/why-aes-is-secure/aes-subbytes.svg" alt="AES SubBytes (Credits: Wikimedia)" />
<figcaption aria-hidden="true">AES SubBytes (Credits: <a href="https://commons.wikimedia.org/wiki/File:AES-SubBytes.svg">Wikimedia</a>)</figcaption>
</figure>
<p>A fixed S-box is used, taking in a byte as input and also producing a byte.The S-box of AES is calculated from the <a href="https://en.wikipedia.org/wiki/Multiplicative_inverse" title="Multiplicative inverse">multiplicative inverse</a> over <span class="math inline">\(GF(2^8)\)</span>. The presence of multiplicative inverse for all elements is one of the properties that fields satisfy.</p>
<p>A multiplicative inverse for a number <span class="math inline">\(x\)</span> is a number which when multiplied by <span class="math inline">\(x\)</span> gives the multiplicative identity <span class="math inline">\(1\)</span>. The multiplicative identity <span class="math inline">\(1\)</span> satisfies the property that <span class="math inline">\(x \times 1 = x\)</span>. In the field of rational numbers, we call the multiplicative inverse the reciprocal, or <span class="math inline">\(\frac{1}{x}\)</span>.</p>
<p>In a Galois field, there is a more complex procedure used in order to find the multiplicative inverse, known as the <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm" title="Extended Euclidean algorithm">Extended Euclidean Algorithm</a>. It turns out that the multiplicative inverses have good non-linearity properties, adding security against attacks which recover the key by exploiting linearity in the S-box.</p>
<p>In addition to the multiplicative inverses, an <a href="https://en.wikipedia.org/wiki/Affine_transformation" title="Affine transformation">affine transformation</a> is used which I will not elaborate on. This allows it to be resistant to <a href="https://en.wikipedia.org/wiki/Linear_cryptanalysis" title="Linear cryptanalysis">linear</a> and <a href="https://en.wikipedia.org/wiki/Differential_cryptanalysis" title="Differential cryptanalysis">differential cryptanalysis</a>, as well as algebraic attacks.</p>
<p>For more details on the design of the S-box, look at <a href="https://en.wikipedia.org/wiki/Rijndael_S-box" title="Rijndael S-box">Rijndael S-box</a>.</p>
<h3 id="shiftrows-and-mixcolumns"><code>ShiftRows</code> and <code>MixColumns</code></h3>
<p>These two operations are what permutates the bits (techincally speaking, <code>MixColumns</code> does more than just permutations).</p>
<figure>
<img src="../../public/crypto/why-aes-is-secure/aes-shiftrows.svg" alt="AES ShiftRows (Credits: Wikimedia)" />
<figcaption aria-hidden="true">AES ShiftRows (Credits: <a href="https://commons.wikimedia.org/wiki/File:AES-ShiftRows.svg">Wikimedia</a>)</figcaption>
</figure>
<p><code>ShiftRows</code> just rotates each row by varying number of bytes. The first row is not rotated, the second row is rotated to the left by one byte, the third row is rotated to the left by two bytes, etc. This permutates the order of the outputs from the S-box <strong>row-wise</strong>.</p>
<figure>
<img src="../../public/crypto/why-aes-is-secure/aes-mixcolumns.svg" alt="AES MixColumns (Credits: Wikimedia)" />
<figcaption aria-hidden="true">AES MixColumns (Credits: <a href="https://commons.wikimedia.org/wiki/File:AES-MixColumns.svg">Wikimedia</a>)</figcaption>
</figure>
<p><code>MixColumns</code> performs a transformation on each column of the matrix. It multiplies the matrix of bytes with:</p>
<p><span class="math display">\[
\begin{bmatrix}
2 &amp; 3 &amp; 1 &amp; 1 \\
1 &amp; 2 &amp; 3 &amp; 1 \\
1 &amp; 1 &amp; 2 &amp; 3 \\
3 &amp; 1 &amp; 1 &amp; 2 \\
\end{bmatrix}
\]</span></p>
<p>in <span class="math inline">\(GF(2^8)\)</span>. Matrix multiplication is composed of several multiplication and addition operations. This transforms the bytes of every column. Hence, <code>MixColumns</code> permutates the bits <strong>column-wise</strong>.</p>
<p>This matrix is a <a href="https://en.wikipedia.org/wiki/MDS_matrix" title="MDS matrix">Maximum Distance Seperable matrix</a>. The power of MDS matrices lie in the fact that they have perfect diffusion. Changing <span class="math inline">\(k\)</span> of the input bytes would change at least <span class="math inline">\(m-k+1\)</span> of the output bytes, where <span class="math inline">\(m \times n\)</span> is the size of the matrix.</p>
<p>Combining both operations together, you get a very powerful P-box. As part of a SPN, this P-box helps to ensure <em>diffusion</em>, and does it very well. It propagates changes in the plaintext throughout, making differential cryptanalysis tough.</p>
<h3 id="addroundkey"><code>AddRoundKey</code></h3>
<p>This is just a XOR operation as described in <a href="#substitution-permutation-network">the section on SPNs</a>.</p>
<h2 id="conclusions-on-aes">Conclusions on AES</h2>
<p>AES remains a very strong cipher. Bruce Schneier, a developer of Twofish, has written in 2000:</p>
<blockquote>
<p>I believe that within the next five years someone will discover an academic attack against Rijndael. I do not believe that anyone will ever discover an attack that will allow someone to read Rijndael traffic. So while I have serious academic reservations about Rijndael, I do not have any engineering reservations about Rijndael.</p>
</blockquote>
<p>Since then, academic attacks against AES have been developed. But many of them involve a smaller number of rounds or are impractical. The best key-recovery attacks on full AES so far is a <a href="https://en.wikipedia.org/wiki/Biclique_attack" title="Biclique attack">biclique attack</a> which is merely faster than brute force by at most a factor of 4. Furthermore, the data storage required works out to trillions of terabytes, far beyond the data stored on the planet.</p>
<p>In addition to its strength, AES performs very quickly. <code>SubBytes</code> and multiplication in <code>MixColumns</code> can be replaced with a lookup table of 256 bytes. Its simplicity means that operations can be performed very fast, and is easily implemented on hardware. All of these properties are why Rijndael was chosen by NIST to become AES.</p>
<p>If you want to know more about AES, take a look at <a href="http://www.moserware.com/2009/09/stick-figure-guide-to-advanced.html" title="A Stick Figure Guide to the Advanced Encryption Standard (AES)">A Stick Figure Guide to AES</a>. Alternatively, if you want to read more on the design of AES, there’s a comprehensive reference written by the creators themselves, titled <a href="http://www.springer.com/gp/book/9783540425809" title="The Design of Rijndael">The Design of Rijndael</a>.</p></div>

<hr />

<aside>
  <small>
    <p>
      <em>
        You can view the history of changes made to this post at
        <a href="https://github.com/wei2912/wei2912.github.io/blame/master/posts/crypto/why-aes-is-secure.md">this website's GitHub repository</a>.
      </em>
    </p>
  </small>
</aside>

<script src="https://utteranc.es/client.js" repo="wei2912/wei2912.github.io" issue-term="title" label="comments" theme="github-light" crossorigin="anonymous" async></script>

<hr />

    <footer>
      <small>
        <p>
          <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
            <img alt="Creative Commons License" style="border-width: 0" src="https://licensebuttons.net/l/by/4.0/88x31.png" /> </a><br />
          This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.<br />
          The source of the website is available at
          <a href="https://github.com/wei2912/wei2912.github.io">wei2912/wei2912.github.io</a>.<br />
        </p>
      </small>
    </footer>
  </body>
</html>
